{
    "version": "https://jsonfeed.org/version/1",
    "title": "HT的小天地 • All posts by \"nodejs\" tag",
    "description": "",
    "home_page_url": "https://xhtgit.github.io/HTworld.github.io",
    "items": [
        {
            "id": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/Node%20JS-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8Anpm%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/",
            "url": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/Node%20JS-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8Anpm%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/",
            "title": "NodeJS之模块加载机制及npm指令详解",
            "date_published": "2023-03-21T15:44:58.284Z",
            "content_html": "<h2 id=\"模块化\"><a class=\"markdownIt-Anchor\" href=\"#模块化\">#</a> 模块化</h2>\n<p>模块化：是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元<br>\n编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。<br>\n把代码进行模块化拆分的好处</p>\n<ul>\n<li>提高了代码的复用性</li>\n<li>提高了代码的可维护性</li>\n<li>可以实现按需加载<br>\n<strong>模块化规范</strong>：就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。例如使用什么样的语法格式来引用模块，在模块中使用什么样的语法格式向外暴露成员<br>\n<strong>模块化规范的好处</strong>：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己</li>\n</ul>\n<h3 id=\"nodejs-中的模块化\"><a class=\"markdownIt-Anchor\" href=\"#nodejs-中的模块化\">#</a> Node.js 中的模块化</h3>\n<p>Node.js 中模块的分类</p>\n<p>Node.js 中根据模块来源的不同，将模块分为了 3 大类</p>\n<pre><code>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）\n自定义模块（用户创建的每个 .js 文件，都是自定义模块）\n第三方模块（由第三方开发出来的模块，使用前需要先下载）\n</code></pre>\n<h4 id=\"加载模块\"><a class=\"markdownIt-Anchor\" href=\"#加载模块\">#</a> 加载模块</h4>\n<p>使用强大的  <code>require()</code>  方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用<br>\n注意：使用 require () 方法加载其它模块时，会<strong>执行</strong>被加载模块中的代码<br>\n不用.js 后缀名也可以加载对应的文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;)\t\t\t\t\t\t\t// 内置模块</span><br><span class=\"line\">const custom = require(&#x27;./custom.js&#x27;)\t// 自定义模块，需指明路径，可以省略 .js 的后缀名</span><br><span class=\"line\">const moment = require(&#x27;moment&#x27;)\t\t\t// 第三方模块</span><br></pre></td></tr></table></figure>\n<h4 id=\"nodejs-中的模块作用域\"><a class=\"markdownIt-Anchor\" href=\"#nodejs-中的模块作用域\">#</a> Node.js 中的模块作用域</h4>\n<p><strong>模块作用域</strong>：和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制<br>\n模块作用域的好处：防止了全局变量污染的问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 模块作用域</span><br><span class=\"line\">const username = &#x27;张三&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">function sayHello() &#123;</span><br><span class=\"line\">  console.log(&#x27;大家好，我是&#x27; + username)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出是空对象，说明模块内定义的变量只能在模块内被访问</p>\n<h4 id=\"向外共享模块作用域中的成员\"><a class=\"markdownIt-Anchor\" href=\"#向外共享模块作用域中的成员\">#</a> 向外共享模块作用域中的成员</h4>\n<p><strong>module 对象</strong></p>\n<p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息<br>\n<strong> module.exports 对象</strong></p>\n<ul>\n<li>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用</li>\n<li>外界用 require () 方法导入自定义模块时，得到的就是 module.exports 所指向的对象，而一般默认该属性是 {} 即空对象。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const age = 20</span><br><span class=\"line\"></span><br><span class=\"line\">// 向 module.exports 对象上挂载 username 属性</span><br><span class=\"line\">module.exports.username = &#x27;zs&#x27;</span><br><span class=\"line\">// 向 module.exports 对象上挂载 sayHello 方法</span><br><span class=\"line\">module.exports.sayHello = function() &#123;</span><br><span class=\"line\">  console.log(&#x27;Hello!&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports.age = age//再共享出去</span><br><span class=\"line\"></span><br><span class=\"line\">// 让 module.exports 指向一个全新的对象</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  nickname: &#x27;小黑&#x27;,</span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    console.log(&#x27;Hi!&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"exports-和-moduleexports-的使用误区\"><a class=\"markdownIt-Anchor\" href=\"#exports-和-moduleexports-的使用误区\">#</a> exports 和 module.exports 的使用误区</h4>\n<ul>\n<li>\n<p>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。</p>\n</li>\n<li>\n<p>时刻谨记，require () 模块时，得到的永远是 module.exports 指向的对象，若出现 exports 和 module.exports，最终不管 exports 怎么指向，都输出 module.exports。注意挂载属性和指向新对象的区别。</p>\n</li>\n</ul>\n<p><img data-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3c927b4c4444ae5a9600655f27d2999~tplv-k3u1fbpfcp-watermark.image?\" alt=\"f4fb24bbee59bf4a5f9f58d8d2024bdb.png\"><br>\n <code>为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const age = 20</span><br><span class=\"line\"></span><br><span class=\"line\">// 向 module.exports 对象上挂载 username 属性</span><br><span class=\"line\">module.exports.username = &#x27;zs&#x27;</span><br><span class=\"line\">// 向 module.exports 对象上挂载 sayHello 方法</span><br><span class=\"line\">module.exports.sayHello = function() &#123;</span><br><span class=\"line\">  console.log(&#x27;Hello!&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">// 让 module.exports 指向一个全新的对象 </span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  nickname: &#x27;小黑&#x27;,</span><br><span class=\"line\">  sayHi() &#123;</span><br><span class=\"line\">    console.log(&#x27;Hi!&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"nodejs-中的模块化规范\"><a class=\"markdownIt-Anchor\" href=\"#nodejs-中的模块化规范\">#</a> Node.js 中的模块化规范</h4>\n<p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖</p>\n<ul>\n<li>每个模块内部，module 变量代表当前模块</li>\n<li>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口</li>\n<li>加载某个模块，其实是加载该模块的 module.exports 属性。require () 方法用于加载模块</li>\n</ul>\n<h3 id=\"npm与包\"><a class=\"markdownIt-Anchor\" href=\"#npm与包\">#</a> npm 与包</h3>\n<p>Node.js 中的第三方模块又叫做包</p>\n<p>不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。Node.js 中的包都是免费且开源的</p>\n<ul>\n<li>\n<p>由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低</p>\n</li>\n<li>\n<p>包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率</p>\n</li>\n<li>\n<p>包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系</p>\n<p>从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tLyVFNyVCRCU5MSVFNyVBQiU5OSVFNCVCOCU4QSVFNiU5MCU5QyVFNyVCNCVBMiVFOCU4NyVBQSVFNSVCNyVCMSVFNiU4OSU4MCVFOSU5QyU4MCVFOCVBNiU4MSVFNyU5QSU4NCVFNSU4QyU4NQ==\">https://www.npmjs.com/ 网站上搜索自己所需要的包</span><br>\n从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcv\">https://registry.npmjs.org/</span> 服务器上下载自己需要的包</p>\n</li>\n</ul>\n<p>npm, Inc. 公司提供了一个包管理工具，使用这个工具从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcv\">https://registry.npmjs.org/</span> 服务器把需要的包下载到本地使用。</p>\n<p>工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。在终端中</p>\n<p>执行 npm -v 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号</p>\n<h4 id=\"npm-安装\"><a class=\"markdownIt-Anchor\" href=\"#npm-安装\">#</a> npm 安装</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dateFormat.js</span><br><span class=\"line\"></span><br><span class=\"line\">// 1. 定义格式化时间的方法</span><br><span class=\"line\">function dateFormat(dtStr) &#123;</span><br><span class=\"line\">  const dt = new Date(dtStr)</span><br><span class=\"line\"></span><br><span class=\"line\">  const y = dt.getFullYear()</span><br><span class=\"line\">  const m = padZero(dt.getMonth() + 1)</span><br><span class=\"line\">  const d = padZero(dt.getDate())</span><br><span class=\"line\">  const hh = padZero(dt.getHours())</span><br><span class=\"line\">  const mm = padZero(dt.getMinutes())</span><br><span class=\"line\">  const ss = padZero(dt.getSeconds())</span><br><span class=\"line\"></span><br><span class=\"line\">  return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义补零的函数</span><br><span class=\"line\">function padZero(n) &#123;</span><br><span class=\"line\">  return n &gt; 9 ? n : &#x27;0&#x27; + n</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  dateFormat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 导入需要的包</span><br><span class=\"line\">// 注意：导入的名称，就是装包时候的名称</span><br><span class=\"line\">const moment = require(&#x27;moment&#x27;)</span><br><span class=\"line\">//查文档看用法</span><br><span class=\"line\">const dt = moment().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)//对时间进行格式化</span><br><span class=\"line\">console.log(dt)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入自定义的格式化时间的模块</span><br><span class=\"line\">const TIME = require(&#x27;./dateFormat&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用方法，进行时间的格式化</span><br><span class=\"line\">const dt = new Date()</span><br><span class=\"line\">// console.log(dt)</span><br><span class=\"line\">const newDT = TIME.dateFormat(dt)</span><br><span class=\"line\">console.log(newDT)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在项目中安装包的命令\"><a class=\"markdownIt-Anchor\" href=\"#在项目中安装包的命令\">#</a> 在项目中安装包的命令</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install 包的完整名称</span><br><span class=\"line\">或者</span><br><span class=\"line\">npm i 包的完整名称</span><br><span class=\"line\">npm i 包的完整名称 包的完整名称（加空格可以安装多个包）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入自定义的格式化时间的模块</span><br><span class=\"line\">const TIME = require(&#x27;./dateFormat&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用方法，进行时间的格式化</span><br><span class=\"line\">const dt = new Date()</span><br><span class=\"line\">// console.log(dt)</span><br><span class=\"line\">const newDT = TIME.dateFormat(dt)</span><br><span class=\"line\">console.log(newDT)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。</p>\n<ul>\n<li>node_modules 文件夹用来存放所有已安装到项目中的包。require () 导入第三方包时，从这个目录中查找并加载</li>\n<li>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;requires&quot;: true,</span><br><span class=\"line\">  &quot;lockfileVersion&quot;: 1,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;moment&quot;: &#123;</span><br><span class=\"line\">      &quot;version&quot;: &quot;2.29.1&quot;,</span><br><span class=\"line\">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/moment/-/moment-2.29.1.tgz&quot;,</span><br><span class=\"line\">      &quot;integrity&quot;: &quot;sha512-kHmoybcPV8Sqy59DwNDY3Jefr64lK/by/da0ViFcuA4DH0vQg5Q6Ze5VimxkfQNSC+Mls/Kx53s7TjP1RhFEDQ==&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>不要手动修改 node_modules 或 package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们</code></p>\n<h4 id=\"安装指定版本的包\"><a class=\"markdownIt-Anchor\" href=\"#安装指定版本的包\">#</a> 安装指定版本的包</h4>\n<p>npm install 命令默认安装最新版本的包。如需安装指定版本的包，在包名之后，@</p>\n<p>npm i 包的完整名称 @版本号</p>\n<pre><code>1\n</code></pre>\n<p>不用删除以前的版本，npm 会自动覆盖之前的版本。</p>\n<h4 id=\"版本号\"><a class=\"markdownIt-Anchor\" href=\"#版本号\">#</a> 版本号</h4>\n<p>包的版本号以 “点分十进制” 形式进行定义，总共有三位数字，如 2.24.0。其中每一位数字所代表的的含义如下</p>\n<pre><code>第1位数字：大版本\n第2位数字：功能版本\n第3位数字：Bug修复版本\n</code></pre>\n<p>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零<br>\n包管理配置文件</p>\n<p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。如</p>\n<pre><code>项目的名称、版本号、描述等\n项目中都用到了哪些包\n哪些包只在开发期间会用到\n那些包在开发和部署时都需要用到\n\n多人协作的问题\n\n遇到的问题：第三方包的体积过大，不方便团队成员之间共享项目源代码。\n\n解决方案：共享时剔除 node_modules\n\n如何记录项目中安装了哪些包\n\n在项目根目录 package.json 的配置文件用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码\n\n注意：今后在项目开发中，一定要把 node_modules文件夹，添加到 .gitignore 忽略文件中\n</code></pre>\n<h4 id=\"快速创建-packagejson\"><a class=\"markdownIt-Anchor\" href=\"#快速创建-packagejson\">#</a> 快速创建 package.json</h4>\n<p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>上述命令只能在英文的目录下成功运行！所以项目文件夹的名称一定要<strong>使用英文命名，不能出现空格</strong></p>\n</li>\n<li>\n<p><strong>运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json</strong></p>\n</li>\n</ul>\n<h4 id=\"一次性安装所有的包\"><a class=\"markdownIt-Anchor\" href=\"#一次性安装所有的包\">#</a> 一次性安装所有的包</h4>\n<p>拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。否则会报类似于下面的错误</p>\n<p><img data-src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c454ba6fc1d467786040e7ed7242a95~tplv-k3u1fbpfcp-watermark.image?\" alt=\"b9aaf60189f251209d1b929fe38c8d59.png\"><br>\n 可以运行  <code>npm install</code>  命令（或 npm i）一次性安装所有的依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"卸载包\"><a class=\"markdownIt-Anchor\" href=\"#卸载包\">#</a> 卸载包</h4>\n<p>运行  <code>npm uninstall</code>  命令，来卸载指定的包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall 包名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉</p>\n<h4 id=\"devdependencies节点\"><a class=\"markdownIt-Anchor\" href=\"#devdependencies节点\">#</a> devDependencies 节点</h4>\n<p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。可以使用如下的命令，将包记录到 devDependencies 节点中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//完整写法 包名和--save-dev顺序不重要</span><br><span class=\"line\">npm install 包名 --save-dev     </span><br><span class=\"line\">或</span><br><span class=\"line\">//常用简写</span><br><span class=\"line\">npm i 包名 -D</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决下包速度慢的问题\"><a class=\"markdownIt-Anchor\" href=\"#解决下包速度慢的问题\">#</a> <strong>解决下包速度慢的问题</strong></h4>\n<ol>\n<li>npm 下包的时候，默认从国外的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcv\">https://registry.npmjs.org/</span> 服务器进行下载，可能会慢</li>\n<li>使用国内镜像服务器 - 淘宝，大幅改善下载速度</li>\n</ol>\n<p><img data-src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82ffaa81be4a4df69164986bc7231d41~tplv-k3u1fbpfcp-watermark.image?\" alt=\"72a14b6dbd9b216b1a31793bf56864df.png\"></p>\n<h4 id=\"切换npm-的下包镜像源\"><a class=\"markdownIt-Anchor\" href=\"#切换npm-的下包镜像源\">#</a> 切换 npm 的下包镜像源</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry \t# 查看当前包镜像源</span><br><span class=\"line\">npm config set registry=http://registry.npm.taobao.org/ # 切换源头</span><br><span class=\"line\">npm config get registry \t# 检查镜像源是否下载成功</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>为了方便的切换下包的镜像源，安装<strong> nrm</strong> 小工具，利用 nrm 提供的终端命令，快速查看和切换下包的镜像源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install nrm -g\t# -g 全局可用</span><br><span class=\"line\">nrm ls\t\t\t\t\t\t\t# 查看当前可用的镜像源地址list</span><br><span class=\"line\">nrm use taobao\t\t\t# 切换镜像源</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"包的分类\"><a class=\"markdownIt-Anchor\" href=\"#包的分类\">#</a> 包的分类</h4>\n<p>使用 npm 包管理工具下载的包，共分为两大类，分别是<br>\n<strong>项目包</strong></p>\n<p>那些被安装到项目的 node_modules 目录中的包，都是项目包。项目包又分为两类</p>\n<pre><code>开发依赖包（被记录到 devDependencies节点中的包，只在开发期间会用到）npm i 包名 -D\n\n核心依赖包（被记录到 dependencies节点中的包，在开发期间和项目上线之后都会用到）npm i 包名\n</code></pre>\n<p><strong>全局包</strong></p>\n<p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包</p>\n<p>全局包会被安装到 C:\\Users\\ 用户目录 \\AppData\\Roaming\\npm\\node_modules 目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install 包名 -g\t# 全局安装指定的包</span><br><span class=\"line\">npm uninstall 包名 -g\t# 卸载全局指定的包</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注意</p>\n<ul>\n<li><strong>只有工具性质的包，才有全局安装的必要性</strong>。因为它们提供了好用的终端命令</li>\n<li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</li>\n</ul>\n<h5 id=\"i5ting_toc\"><a class=\"markdownIt-Anchor\" href=\"#i5ting_toc\">#</a> i5ting_toc</h5>\n<p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i i5ting_toc -g\t\t\t# 安装</span><br><span class=\"line\">i5ting_toc -f sample.md -o\t\t# 转换</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"规范的包结构\"><a class=\"markdownIt-Anchor\" href=\"#规范的包结构\">#</a> 规范的包结构</h4>\n<p>一个规范的包，它的组成结构，必须符合以下 3 点要求</p>\n<ul>\n<li>包必须以单独的目录而存在</li>\n<li>包的顶级目录（点进去的目录）下要必须包含 package.json 这个包管理配置文件</li>\n<li>package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口 (.js 文件)（require () 加载的文件）</li>\n</ul>\n<p>关于更多的约束参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly95YXJucGtnLmNvbS96aC1IYW5zL2RvY3MvcGFja2FnZS1qc29u\">https://yarnpkg.com/zh-Hans/docs/package-json</span><br>\n 开发包</p>\n<p>1 新建 itheima-tools 文件夹，作为包的根目录<br>\n 2 在 itheima-tools 文件夹中，新建。也可以直接初始化（npm init -y）<br>\npackage.json （包管理配置文件）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;itheima-tools&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.1.0&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;提供了格式化时间、HTMLEscape相关的功能&quot;,//检索时出现的功能介绍</span><br><span class=\"line\">  &quot;keywords&quot;: [//搜索关键词</span><br><span class=\"line\">    &quot;itheima&quot;,</span><br><span class=\"line\">    &quot;dateFormat&quot;,</span><br><span class=\"line\">    &quot;escape&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;license&quot;: &quot;ISC&quot;//协议</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>●index.js （包的入口文件）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src 文件夹下开发代码，导入到 index.js 中</span><br><span class=\"line\">const date = require(&#x27;./src/dateFormat&#x27;)</span><br><span class=\"line\">const escape = require(&#x27;./src/htmlEscape&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 向外暴露需要的成员</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  ...date,\t\t// ... 展开运算符，将data所有属性交给新对象</span><br><span class=\"line\">  ...escape\t\t// ... 展开运算符，将escape所有属性交给新对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>src 源代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dateFormat.js</span><br><span class=\"line\"></span><br><span class=\"line\">function dateFormat(dateStr) &#123;/* 略 */&#125;</span><br><span class=\"line\">function padZero(n) &#123;return n &gt; 9 ? n : &#x27;0&#x27; + n&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  dateFormat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// htmlEscape.js</span><br><span class=\"line\"></span><br><span class=\"line\">function htmlEscape(htmlstr) &#123;/* 略 */&#125;</span><br><span class=\"line\">function htmlUnEscape(str) &#123;/* 略 */&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  htmlEscape,</span><br><span class=\"line\">  htmlUnEscape</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL1JFQURNRS5tZA==\">README.md</span> （包的说明文档）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装</span><br><span class=\"line\"></span><br><span class=\"line\">npm install itheima-tools</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">导入</span><br><span class=\"line\"></span><br><span class=\"line\">const itheima = require(&#x27;itheima-tools&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">格式化时间</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用 dateFormat 对时间进行格式化</span><br><span class=\"line\">const dtStr = itheima.dateFormat(new Date())</span><br><span class=\"line\">// 结果  2020-04-03 17:20:58</span><br><span class=\"line\">console.log(dtStr)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">转义 HTML 中的特殊字符</span><br><span class=\"line\"></span><br><span class=\"line\">略</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">原 HTML 中的特殊字符</span><br><span class=\"line\"></span><br><span class=\"line\">略</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">开源协议</span><br><span class=\"line\">ISC</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const itheima = require(&#x27;./itheima-tools&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 格式化时间的功能</span><br><span class=\"line\">const dtStr = itheima.dateFormat(new Date())</span><br><span class=\"line\">console.log(dtStr)</span><br><span class=\"line\">console.log(&#x27;-----------&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">const htmlStr = &#x27;&lt;h1 title=&quot;abc&quot;&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt;&#x27;</span><br><span class=\"line\">const str = itheima.htmlEscape(htmlStr)</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">console.log(&#x27;-----------&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">const str2 = itheima.htmlUnEscape(str)</span><br><span class=\"line\">console.log(str2)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>发布包</p>\n<pre><code>https://www.npmjs.com/ 注册 npm 账号\n\n在终端登录，终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功\n\n注意：执行命令前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！先用nrm命令检查一下，nrm use 命令切换。\n\n终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）\n\n运行 npm unpublish 包名 --force命令，即可从 npm 删除已发布的包\n●npm unpublish 命令只能删除 72 小时以内发布的包\n●npm unpublish 删除的包，在 24 小时内不允许重复发布\n●发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包\n</code></pre>\n<h3 id=\"模块的加载机制\"><a class=\"markdownIt-Anchor\" href=\"#模块的加载机制\">#</a> 模块的加载机制</h3>\n<p>模块在第一次加载后会被缓存，多次调用 require () 模块的代码只会被执行一次。不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p>\n<h4 id=\"内置模块的加载机制\"><a class=\"markdownIt-Anchor\" href=\"#内置模块的加载机制\">#</a> 内置模块的加载机制</h4>\n<p>​ ●内置模块的加载优先级最高（当第三方模块和内置模块同名时）</p>\n<h4 id=\"自定义模块的加载机制\"><a class=\"markdownIt-Anchor\" href=\"#自定义模块的加载机制\">#</a> 自定义模块的加载机制</h4>\n<p>●使用 require () 加载自定义模块时，必须指定以 ./ 或 …/ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 …/ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p>\n<p>●在使用 require () 导入自定义模块时，如果省略了文件的扩展名，Node.js 会按顺序分别尝试加载以下的文件</p>\n<pre><code>​ 按照确切的文件名进行加载\n​ 补全 .js 扩展名进行加载\n​ 补全 .json 扩展名进行加载\n​ 补全 .node 扩展名进行加载\n​ 加载失败，终端报错\n</code></pre>\n<h4 id=\"第三方模块的加载机制\"><a class=\"markdownIt-Anchor\" href=\"#第三方模块的加载机制\">#</a> 第三方模块的加载机制</h4>\n<p>​ ●如果传递给 require () 的模块标识符不是一个内置模块，也没有以 ./ 或 …/ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块<br>\n​ ●如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录<br>\n​ ●假设在 ‘C:\\Users\\itheima\\project\\node_modules\\a.js’ 里调用 require (‘tools’)，Node.js 会按以下顺序查找</p>\n<pre><code>C:\\Users\\itheima\\project\\node_modules\\tools\nC:\\Users\\itheima\\node_modules\\tools\nC:\\Users\\node_modules\\tools\nC:\\node_modules\\tools\n报错\n</code></pre>\n<h4 id=\"目录作为模块\"><a class=\"markdownIt-Anchor\" href=\"#目录作为模块\">#</a> 目录作为模块</h4>\n<p>●当把目录作为模块标识符，传递给 require () 进行加载的时候，有三种加载方式</p>\n<pre><code>在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性值作为 require() 加载的入口\n如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件\n如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx’\n</code></pre>\n",
            "tags": [
                "NodeJS"
            ]
        },
        {
            "id": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/NodeJS-fs%E6%A8%A1%E5%9D%97/",
            "url": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/NodeJS-fs%E6%A8%A1%E5%9D%97/",
            "title": "NodeJS之fs",
            "date_published": "2023-03-21T15:44:11.353Z",
            "content_html": "<h2 id=\"nodejs简介\"><a class=\"markdownIt-Anchor\" href=\"#nodejs简介\">#</a> NodeJs 简介</h2>\n<h4 id=\"什么是-nodejs\"><a class=\"markdownIt-Anchor\" href=\"#什么是-nodejs\">#</a> 什么是 Node.js</h4>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境</p>\n<h4 id=\"nodejs-中的-javascript-运行环境\"><a class=\"markdownIt-Anchor\" href=\"#nodejs-中的-javascript-运行环境\">#</a> Node.js 中的 JavaScript 运行环境</h4>\n<ul>\n<li>浏览器是 JavaScript 的前端运行环境</li>\n<li>Node.js 是 JavaScript 的后端运行环境</li>\n<li>Node.js 中无法调用 DOM 和 BOM 等浏览器内置 API</li>\n</ul>\n<h4 id=\"nodejs-可以做什么\"><a class=\"markdownIt-Anchor\" href=\"#nodejs-可以做什么\">#</a> Node.js 可以做什么</h4>\n<p>Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位</p>\n<ul>\n<li>基于 Express 框架 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leHByZXNzanMuY29tLmNuLw==\">http://www.expressjs.com.cn/</span> 可以快速构建 Web 应用</li>\n<li>基于 Electron 框架 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy8=\">https://electronjs.org/</span> 可以构建跨平台的桌面应用</li>\n<li>基于 restify 框架 <span class=\"exturl\" data-url=\"aHR0cDovL3Jlc3RpZnkuY29tLw==\">http://restify.com/</span> 可以快速构建 API 接口项目</li>\n<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>\n</ul>\n<h2 id=\"终端的一些快捷键\"><a class=\"markdownIt-Anchor\" href=\"#终端的一些快捷键\">#</a> 终端的一些快捷键</h2>\n<p>shift + 鼠标右键 可以在该目录下打开 powershell 窗口<br>\n在 powershell 中的快捷键：</p>\n<ul>\n<li>⬆，可以快速定位到上一次执行的命令。</li>\n<li>tab 键，可以快速补全文件的路径（先输入第一个字，然后使用 tab 键，可以快速补全路径）</li>\n<li>ESC，可以快速清空已输入的命令</li>\n<li>cls，清空 powershell 面板</li>\n<li>./ 表示为当前目录，写不写都可以</li>\n</ul>\n<h2 id=\"fs-文件系统模块\"><a class=\"markdownIt-Anchor\" href=\"#fs-文件系统模块\">#</a> fs 文件系统模块</h2>\n<h4 id=\"什么是-fs-文件系统模块\"><a class=\"markdownIt-Anchor\" href=\"#什么是-fs-文件系统模块\">#</a> 什么是 fs 文件系统模块</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs 模块是 Node.js 官方提供的、用来操作文件的模块。提供了一系列的方法和属性，用来满足对文件的操作需求  </span><br></pre></td></tr></table></figure>\n<p>如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&quot;fs&quot;)</span><br></pre></td></tr></table></figure>\n<p><code>fs.readFile(path[, option], callback)</code>  读取指定文件中的内容<br>\n <code>path</code>  必选参数，字符串，文件路径<br>\n <code>option</code>  可选参数，设置字符集<br>\n <code>callback</code>  必选参数，文件读取完成后的回调函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 导入 fs 模块，来操作文件</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 调用 fs.readFile() 方法读取文件</span><br><span class=\"line\">//    参数1：读取文件的存放路径</span><br><span class=\"line\">//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8</span><br><span class=\"line\">//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr</span><br><span class=\"line\">fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 2.1 打印失败的结果</span><br><span class=\"line\">  // 如果读取成功，则 err 的值为 null</span><br><span class=\"line\">  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined</span><br><span class=\"line\">  console.log(err)</span><br><span class=\"line\">  console.log(&#x27;-------&#x27;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 2.2 打印成功的结果</span><br><span class=\"line\">  console.log(dataStr)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//一般逻辑可以这么写：</span><br><span class=\"line\">fs.readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    return console.log(&#x27;读取文件失败！&#x27; + err.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(&#x27;读取文件成功！&#x27; + dataStr)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>fs.writeFile(path, data[, option], callback)</code>  向指定的文件中写入内容<br>\n <code>path</code>  必选参数，字符串，文件路径<br>\n <code>data</code>  必选参数，写入的内容<br>\n <code>option</code>  可选参数，设置字符集，默认值是 utf<br>\n <code>callback</code>  必选参数，文件写入完成后的回调函数<br>\n fs.writeFile () 方法只能用来创建文件，不能用来创建路径<br>\n重复调用 fs.writeFile (写入同一个文件，新写入的内容会覆盖之前的旧内容<br>\n<strong>注意：写入会覆盖原内容</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 调用 fs.writeFile() 方法，写入文件的内容</span><br><span class=\"line\">//    参数1：表示文件的存放路径</span><br><span class=\"line\">//    参数2：表示要写入的内容</span><br><span class=\"line\">//    参数3：回调函数</span><br><span class=\"line\">fs.writeFile(&#x27;./files/3.txt&#x27;, &#x27;ok123&#x27;, function(err) &#123;</span><br><span class=\"line\">  // 2.1 如果文件写入成功，则 err 的值等于 null</span><br><span class=\"line\">  // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象</span><br><span class=\"line\">  // console.log(err)</span><br><span class=\"line\">//判断是否写入成功</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    return console.log(&#x27;文件写入失败！&#x27; + err.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(&#x27;文件写入成功！&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>省略第三个参数则默认为 UTF8 格式</strong></p>\n<h4 id=\"路径动拼接的问题\"><a class=\"markdownIt-Anchor\" href=\"#路径动拼接的问题\">#</a> 路径动拼接的问题</h4>\n<p>使用 fs 模块操作文件时，如果提供的操作路径是以./ 或…/ 开头的相对路径时，很容易出现路径动态拼接错误的问题。原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。<br>\n解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供。或…/ 开头的相对路径，从而防止路径动态拼接的问题。注意 js 中写完整路径要用 \\，不然会被当成转义字符处理。但是这种方法移植性差。fs 中有解决办法。<br>\n <code>__dirname</code>  表示当前文件所处的目录 **（即以 js 文件所处地方为基准） <strong>，不会根据打开 node 目录变化而变化</strong>（即为打开 node 的地方为基准）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(__dirname)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    return console.log(&#x27;读取文件失败！&#x27; + err.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(&#x27;读取文件成功！&#x27; + dataStr)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"path-路径模块\"><a class=\"markdownIt-Anchor\" href=\"#path-路径模块\">#</a> path 路径模块</h4>\n<p>path 模块是 Node.js 官方提供的、用来处理路径的模块。提供一系列的方法和属性，用来满足对路径的处理需求。如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&quot;path&quot;)</span><br></pre></td></tr></table></figure>\n<p><code>path.join(...paths)</code>  可以把多个路径片段拼接为完整的路径字符串</p>\n<ul>\n<li>注意：凡是涉及到路径拼接的操作，都要使用 path.join () 方法进行处理。不直接使用 + 进行字符串的拼接</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 注意：  ../ 会抵消前面的路径</span><br><span class=\"line\">const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;)</span><br><span class=\"line\">console.log(pathStr)  // \\a\\b\\d\\e</span><br><span class=\"line\"></span><br><span class=\"line\">// 取代fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, ...)</span><br><span class=\"line\">fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf8&#x27;, function(err, dataStr) &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    return console.log(err.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(dataStr)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>path.basename(path[, ext])</code>  可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名</p>\n<ul>\n<li><strong>path</strong> 必选参数，表示一个路径的字符串</li>\n<li><strong>ext</strong> 可选参数，表示文件扩展名</li>\n<li>返回 路径的最后一部分</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义文件的存放路径</span><br><span class=\"line\">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const fullName = path.basename(fpath)</span><br><span class=\"line\">console.log(fullName) // index.html</span><br><span class=\"line\"></span><br><span class=\"line\">const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)</span><br><span class=\"line\">console.log(nameWithoutExt) // index</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>path.extname(path)</code>  可以获取路径中的扩展名部分</p>\n<ul>\n<li>path 必选参数，表示一个路径的字符串</li>\n<li>返回 返回得到的扩展名字符串</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 这是文件的存放路径</span><br><span class=\"line\">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const fext = path.extname(fpath)</span><br><span class=\"line\">console.log(fext)//输出.html</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "NodeJS"
            ]
        },
        {
            "id": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/NodeJS-http%E6%A8%A1%E5%9D%97/",
            "url": "https://xhtgit.github.io/HTworld.github.io/2023/03/21/NodeJS-http%E6%A8%A1%E5%9D%97/",
            "title": "NodeJS之http",
            "date_published": "2023-03-21T06:03:09.258Z",
            "content_html": "<h2 id=\"http模块\"><a class=\"markdownIt-Anchor\" href=\"#http模块\">#</a> http 模块</h2>\n<p>http 模块是 Node.js 官方提供的用来创建 web 服务器的模块</p>\n<p>通过 http 模块提供的 http.createServer () 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。<br>\n在 Node.js 中，不需要使用 IIS、Apache（针对 php） 等第三方 web 服务器软件（普通的电脑常常安装这些），而是基于 Node.js 提供的 http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务</p>\n<p>导入 http 模块创建 Web 服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&quot;http&quot;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务器相关的概念\"><a class=\"markdownIt-Anchor\" href=\"#服务器相关的概念\">#</a> 服务器相关的概念</h4>\n<ul>\n<li><code>IP地址</code> ，就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把 “个人电脑” 比作 “一台电话”，那么 “IP 地址” 就相当于 “电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。<br>\nIP 地址的格式：通常用 “点分十进制” 表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP 地址（192.168.1.1）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意:</span><br><span class=\"line\">- 互联网中每台 Web 服务器，都有自己的 IP 地址，如：可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址   </span><br><span class=\"line\">- 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了</span><br></pre></td></tr></table></figure>\n<h4 id=\"域名和域名服务器\"><a class=\"markdownIt-Anchor\" href=\"#域名和域名服务器\">#</a> 域名和域名服务器</h4>\n<p>尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。</p>\n<p>IP 地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器 (DNS，Domain name server) 的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便</span><br><span class=\"line\">- 在开发测试期间， 127.0.0.1对应的域名是 localhost，都代表自己的这台电脑，在使用效果上没有任何区别</span><br></pre></td></tr></table></figure>\n<h4 id=\"端口号\"><a class=\"markdownIt-Anchor\" href=\"#端口号\">#</a> 端口号</h4>\n<p>计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。<br>\n同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 每个端口号不能同时被多个 web 服务占用</span><br><span class=\"line\">- 在实际应用中，URL 中的 80 端口可以被省略</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-web-服务器的基本步骤\"><a class=\"markdownIt-Anchor\" href=\"#创建-web-服务器的基本步骤\">#</a> <strong>创建 web 服务器的基本步骤</strong></h3>\n<ol>\n<li>导入 http 模块</li>\n<li>创建 web 服务器实例</li>\n<li><code>server.on()</code>  为服务器实例绑定 request 事件，监听客户端的请求</li>\n<li>启动服务器</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 导入 http 模块</span><br><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 创建 web 服务器实例</span><br><span class=\"line\">const server = http.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span><br><span class=\"line\">server.on(&#x27;request&#x27;, function (req, res) &#123;</span><br><span class=\"line\">  console.log(&#x27;Someone visit our web server.&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 4. 启动服务器</span><br><span class=\"line\">server.listen(8080, function () &#123;  </span><br><span class=\"line\">  console.log(&#x27;server running at http://127.0.0.1:8080&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"req请求对象\"><a class=\"markdownIt-Anchor\" href=\"#req请求对象\">#</a> req 请求对象</h4>\n<p>只要服务器接收到了客户端的请求，就会调用通过 server.on () 为服务器绑定的 request 事件处理函数</p>\n<h4 id=\"res响应对象\"><a class=\"markdownIt-Anchor\" href=\"#res响应对象\">#</a> res 响应对象</h4>\n<p>在服务器 request 事件处理函数中，如果想访问与服务器相关的数据或属性，通过 <code>res.end(data）</code>  方法响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  // req.url 是客户端请求的 URL 地址</span><br><span class=\"line\">  const url = req.url</span><br><span class=\"line\">  // req.method 是客户端请求的 method 类型</span><br><span class=\"line\">  const method = req.method</span><br><span class=\"line\">  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`</span><br><span class=\"line\">  console.log(str)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 调用 res.end() 方法，向客户端响应一些内容</span><br><span class=\"line\">  res.end(str)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"解决中文乱码问题\"><a class=\"markdownIt-Anchor\" href=\"#解决中文乱码问题\">#</a> 解决中文乱码问题</h4>\n<p>当调用 res.end () 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  // 定义一个字符串，包含中文的内容</span><br><span class=\"line\">  const str = `您请求的 URL 地址是 $&#123;req.url&#125;，请求的 method 类型为 $&#123;req.method&#125;`</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题</span><br><span class=\"line\">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // res.end() 将内容响应给客户端</span><br><span class=\"line\">  res.end(str)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"例子\"><a class=\"markdownIt-Anchor\" href=\"#例子\">#</a> 例子</h4>\n<p>根据不同的 url 响应不同的 html 内容</p>\n<ol>\n<li>获取请求的 url 地址</li>\n<li>设置默认的响应内容为 404 Not found</li>\n<li>判断用户请求的是否为 / 或 /index.html 首页</li>\n<li>判断用户请求的是否为 /about.html 关于页面</li>\n<li>设置 Content-Type 响应头，防止中文乱码</li>\n<li>使用 res.end () 把内容响应给客户端</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const server = http.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  // 1. 获取请求的 url 地址</span><br><span class=\"line\">  const url = req.url</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 2. 设置默认的响应内容为 404 Not found</span><br><span class=\"line\">  let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 3. 判断用户请求的是否为 / 或 /index.html 首页</span><br><span class=\"line\">  // 4. 判断用户请求的是否为 /about.html 关于页面</span><br><span class=\"line\">  if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123;</span><br><span class=\"line\">    content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class=\"line\">  &#125; else if (url === &#x27;/about.html&#x27;) &#123;</span><br><span class=\"line\">    content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 5. 设置 Content-Type 响应头，防止中文乱码</span><br><span class=\"line\">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 6. 使用 res.end() 把内容响应给客户端</span><br><span class=\"line\">  res.end(content)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(80, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;server running at http://127.0.0.1&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "NodeJS"
            ]
        }
    ]
}